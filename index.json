[{"content":"2023年1月19日 21点05分 JP\n计算机如何储存数据 输入与输出的交互/转换 计算机和我们人类语言是不通的，计算机只会说阿巴阿巴，所以计算机理解不了我们，但是我们创造了计算机，所以我们可以让计算机来理解我们，我们只需要让他知道，我们的话语如何与它的阿巴阿巴一一对应，这样我们输入的数据，计算机就能处理，同理计算机输出的数据再转回我们人类的话语。\n数据类型 这里面的阿巴阿巴其实就是0和1，我们人为认为规定一堆0和1其所代表的含义，比如0100 0001（十进制65），我们可以规定它是一个正数65，也可以规定它是一个字符A，至于如何规定，就是我们指定数据类型，我们输入的计算机的数据值始终是65，但是如果我们规定数据类型是char那它就是一个字符、我们指定它是unsignen int，那它就是一个正数。\n但是其实如果我们指定何种类型，都不影响数据本身的内容，不管是写到内存还是硬盘，他的数据内容始终是65，但是我们指定其类型可以影响到后续的操作，比如加减运算、显示字符等（在C语言中其实无论什么类型我们都可以加减或者显示字符，但是其他强类型的语言或者不允许，C语言之所以允许这么做是因为这是合法的，因为其本身就是一个数据就是0100 0001而已，怎么解读这串符号取决于我们人类）。\n同样的道理，计算机从磁盘或内存中读取出来的一个数据，我们可以指定它是无符号数或者指定它是有符号数以进行后面的运算，也可以指定它是个字符以将它显示出来，这些类型都取决于我们，与数据本身无关。\n如何区分正负数 以1字节为例，也就是位宽8bit，通过前面的学习我们知道，这8bit能表示256种可能，其数据内容为0~255。那么我们可以规定这0~255个内容(可能)分别对应了数值0和正数1~255。同样的，我们也可以规定它不是一个数，而是字符或者其它的东西。如果这256个可能都用来意思（表示/对应）正数和0的话，那么我们需要用到负数怎么办？于是我们规定了两种数据类型，分别是无符号整型与有符号整型，无符号类型就是用来意思0和正数，而有符号类型我们就可以用来规定计算机这个数据既可以是正数，也可以是负数和0。那当一个数据的类型是有符号整数时，我们又如何区分（规定）负数和正数呢，回想我们的十进制，我们在最高位前面加了一个-来表示负数，可是计算机只会阿巴阿巴（0/1）呀，没有负号呢，于是我们达成共识，用最高位来表示符号，0表示这个数据是个正数或0，1表示这个数据是负数或0。\n那么我们可以用1000 0000来表示-0、1000 0010来表示-2、0000 0010来表示+2，但是这样规定计算机真的好吗？如果我们直接和计算机的0与1打交道的话，这样确实非常直观，但是这样对于计算机来说就很麻烦了，因为这影响它的运算效率。要知道我们有256种映射关系来意思各个正数与负数当然还有0，但是我们并不是非得让这256个映射关系从0开始与自然数和负数有序的对应，我们可以随心所欲的对应。虽然如此但我们不会这样做，我们要从提高运算效能上着手，于是就产生的原码、反码、补码这种东西。\n什么是原码 原码其实就是实际数值，一种有序的对应关系，如是：\n正数1~127用0x01~0x7F来对应 负数-1~-127用0x81~0xFF来对应 0x00和0x80分别表示0和-0 这样是有弊端的，上面我们已经提到了，原码对我们来说，非常的清晰明了，但是不够效能。\n反码与补码 其实对于正数来说，原码就是最优解，所以正数只有原码，也就是规定计算机用原码的方式来储存正数的数据内容。\n负数在数学世界里（运算对应关系）的本质是什么呢，其实就是0-正数对吧。\n0在计算机里是什么呢？是0000 0000没错，但可以换成1111 1111+1即1 0000 0000，最高位会溢出丢弃，其结果也是0。\n这样负数就变成了11111111-正数+1，我们继续看其中的1111 1111-正数是什么？是不是正数每个位取反呀，于是我们把这种数据形式称为反码。\n那么负数到此变成了什么？是不是反码+1呀，而反码+1的结果呢就是我们储存负数的数据形式（即我们以何种形态来储存负数），同样它也有一个特定的名字叫补码。\n通过上述可知：\n反码与补码的起源是解决负数的储存，所以这两者都是相对于负数而言的，对于永远以原码来储存的正数而言毫无意义。 上述的内容中，有一个不可忽略的细节，就是负数的本质是0-正数（其相反数），我们须要知道这里的正数与负数是对应我们的现实世界的数值的，也就是说在计算机里它的符号位在后面的运算中其实是没有参与的，也就是说反码取反的是除符号位以外的位，因此补码的符号位也是没有变的。简而言之，负数无论何种编码方式，其符号位永远是1，未参与其中。（就本质而已，我们要忽略计算机的符号位，因为它只是一个标识而已，并没有参与运算） 2023年1月19日 22点42分 JP\n","permalink":"https://syakiba.github.io/posts/1.012_complement/","summary":"正负数如何在计算机中存储之原码、补码、反码","title":"正负数储存原理"},{"content":"2023年1月19日 19点15分 JP\n进制的本质是什么？ 进制就是一个位所能表示的数的范围，比如我们的十进制，每个位所能表示的数的范围只能是0~9。每个位都有其对应的权重，比如十进制的各位权重是1、十位权重是10、百位权重是100\u0026hellip; 某进制（n进制）的本质是，其只有n个符号用来表示自然数。\n比如十进制的这10个符号就是0~9、十六进制的16个符号中前十个与十进制一样是0~9，后六个是A~F分别代表数值10~15、八进制的八个符号是0~7表示数值0~7、二进制的两个符号是0和1也代表的数值0和1。 如果你愿意，十进制不一定非得写0123这些数字符号，因为它们本身只是一种符号，我们人为的赋予了它们数值的意义并以此为习惯。\n但其实我们完全可以用其他符号来定义数值的大小比如字母甚至我们自己乱花的符号。例如我们可以规定A的意义是数值0、B的意义是数值1，以此类推就可以用A~J分别表示数值0~9，这个时候我们的数值11就是写成BB、数值99写成JJ\u0026hellip;\n什么是权重？ 拿我们十进制来举例，十进制的数：83512，读作8万3千5百1十2，从小我们就知道从右到左，这五个位分别是个位、十位、百位、千位、万位，这里的个十百千万就是权重。\n权重的大小 我们知道每个位上数字符号所代表的实际数值大小其实是符号本身的数值乘上其位的权重。例如83512中5所代表的数值是500并不是5本身，为什么是500而不是50或5000呢，因为他所在的位的权重是100。每个位的权重大小应该是多少呢，可能我们习惯性的认为是每往左一个位（每高一个位）就多乘10，这是没错，但其本质是10的幂。每个位都有其索引，比如个位的索引是0、十位是1、百位是2\u0026hellip;那么每个位的权重就是其10的索引次幂：个位是10^0=1、十位10^1=10、百位10^2=100\u0026hellip;\n同理：n进制数的m位权重为n^m，注意我们这里所说的m，是位的索引，其是从0开始的，但是日常中我们会说第一个位（个位）或者第二各位（十位）\u0026hellip;不可将两个弄混淆\n十六进制的权重大小 0位：16^0=1\n1位：16^1=16\n2位：16^2=256\n3位：16^3=4096\n\u0026hellip;\n例如十六进制数：0x4321（一般我们会用0x前缀或者h后缀来表示某个数是十六进制），从最低位开始，其值分别为1、2\\*16、3\\*16^2、4\\*16^3。（整个数的数值大小就是这四个数值的总和）\n二进制的权重 0位：2^0=1\n1位：2^1=2\n2位：2^2=4\n3位：2^3=8\n4位：2^4=16\n5位：2^5=32\n6位：2^6=64\n7位：2^7=128\n\u0026hellip;\n其中3位是8，为16的一半；7位是128，为128的一半，为什么要提这个呢，他有什么特殊的地方吗？还真有，我们后面再讲。\n位宽是什么 什么是位宽呢，其实很简单，有几个位就是多少位宽，比如我们十进制的500，500占了三个位，这就是位宽3位。\n位宽能获得什么信息呢？位宽限制了一个数值的最大值，就拿位宽3来说，三个位的十进制数，其最大值只能是999。再换个角度来说，位宽也决定了这组符号所能表示的数值范围，还是3位宽，其值只能是0~999，那么其涵盖的数值范围大小就是1000个，也就是说3位十进制数所能承受的可能性是1000种，这1000种可能是0~999中的其中一个。再来思考一下，1000是什么？1000刚好是下一位的权重值，也就是第四位：千位（索引为3的那位），其权重为10^3刚好就是1000。同理，我们可知，n位宽所能表示的可能性是其高一位的权重值，也就是10^n，当然n位宽所能表示的最大数值是10^n-1。\n同样的道理，n位宽的x进制数，其所能表示的可能性有x^n种。\n二进制与十六进制间的奥秘 我们再来看十进制500这个数，我们看一眼都知道这是1000的一半，但是为什么呢？因为5刚好是10的一半，所以500也是同样的道理，0~499是前500种可能，500~999是后一半500种可能。 那十六进制呢，聪明的我们肯定也是一下就明白了，8是16的一半，所以最高位是8就代表进入另一半可能了。比如0x80，前一半的可能性是0~7F，后一半的可能性就是80~FF。那么二进制呢？当然是数字1啦，最高位是1即代表以及进入后一半可能了，是后一半可能中的第一个（前一半可能中的第一个是0）。\n我们的思路再次回到上面二进制权重的地方，还记得二进制3位和7位的权重分别是8和128吗？其写出来就是1000与1000 0000，有没有什么灵感出现？对于二进制数，位宽4的表示范围是8\\*2=16，位宽8的范围是128\\*2=256。而这两个值，16和256同时也是1位宽与2位宽16进制数的表示范围，即1个16进制数与4个二进制数是等效的（1hex=4bits），我们都知道在计算机中，1个字节是8位（bit），所以一个字节可以用8位宽的二进制位数来表示，但也可以用2个16进制位来表示（1Byte=8bits=2hexs**）。\n总结：每个16进制位都与4个二进制位一一对应，即二进制和十六进制位是可以相互转换的，因此十分建议大家记熟16进制位所对应的2进制位是多少，这对于整个计算机的学习后益无穷。\nhex与bit的对应表 hex bit hex bit 0 0000 8 1000 1 0001 9 1001 2 0010 A 1010 3 0011 B 1011 4 0100 C 1100 5 0101 D 1101 6 0110 E 1110 7 0111 F 1111 换个角度看字节 通过上面的叙述，我们是不是可以从另一个角度来看待字节呢，计算机中存取的基本单位是字节，也就是说我们的数据量是建立在字节这个基础之上的，我们可以操作1个字节、2个字节、4个8个\u0026hellip;无数个。\n此时字节这个单位的本质是什么？是进制，什么进制呢，是256进制！一个字节的数据内容就是256种可能中的一个，两个字节就有256*256种可能，4个字节就有256^4种可能。\n从这个角度来看，字节的本质其实就是进制，n个字节的数据合起来看，其本质就是n位宽的256进制数。\n同理KB/MB/GB/TB或者WORD/DWORD/QWORD都可以看成一种很高的进制。\n进制的运算 每个进制都是独立，所以二进制或者16进制的运算并不是要先转成10进制，进行运算后，再将结果转回原来的进制，这样的步骤是十分多余的。\n任何一种进制，它本身都可以独立运算，而这个运算其实很简单，就只有两个基础操作：一个是掐手指，一个是乘法表。\n其中掐手指用来计算加减法，而乘法表用来计算乘除。\n什么是掐手指？ 所谓掐手指其实就是往后查符号，比如我们小时候计算3+5时是怎么做的呢，就是3开始往后掐5个指头（查5个符号），我们从3开始一个一个掐手指：4、5、6、7、8，掐了五个手指时，对应的符号是8，哦原来答案是8。\n其实这个过程的本质就是3这个符号往后查5个符号，也就是8这个符号。由上文可知，每个进制的本质就是符号，因此无论哪种进制，都可以用这种方法来进行加减运算。\n如果加的数很大，手指掐不过来怎么办？其实这也很简单，聪明的我们肯定也想到了，那就是掐脚趾、掐别人的手指和脚趾！开玩笑的啦，其实和十进制一样，我们后来学了列竖式用来进行加减法运算，而列竖式的本质实际上就是每个位分别查符号，因此无论那种进制，我们一样可以在脑海里列出竖式，然后从低位开始，依次查数（并对应的进行进位与借位）。\n进制的乘除运算 我们之所以能够进行十进制的乘除法运算，是因为在我们的脑海里早就根深蒂固的掌握了99乘法表，什么是99乘法表，其本质就是两个符号相乘后所对应的符号，比如符号2和符号8对应的符号就是1 6这两个符号的结合16。\n所以如果当我们掌握了n进制的nn乘法表，那么我们就可以进行口算乘除，当然太大的数一样是在脑海中列竖式，其本质和加减法竖式一样，也是每个位分别查表（并进行对应的进位与进位），只不过加减竖式查的是有序排列表，乘除竖式查的是nn乘法表，就是这么简单！\n当然我们没有必要去背诵16进制乘法表，毕竟我们是有计算器的，当然如果愿意，也是可以去掌握的，毕竟掌握之后的效率要比计算器快很多。\n2023年1月19日 20点57分 JP\n","permalink":"https://syakiba.github.io/posts/2.numb_system/","summary":"进制详解之本质、权重、位宽以及二进制与十六进制间的暧昧","title":"什么是进制"},{"content":" 优雅永不过时：PASCAL / pascal / pas ！ 2023年1月21日 00点37分 JP\n🎵秋天不回来 2023年1月16日 20点31分 JP\n","permalink":"https://syakiba.github.io/isay/","summary":"心生万象","title":"🫧囚言秋羽"},{"content":"2023年1月15日 12点00分 JP\n标题的使用方式 (Title or Heading) 1~6级标题分别用: 1~6个# 空格 来表示\n代码 # heading 1 ## heading 2 ### heading 3 #### heading 4 ##### heading 5 ###### heading 6 效果 heading 1 heading 2 heading 3 heading 4 heading 5 heading 6 换行以及分段 (Rows and Paragraphs) 换行: 空格 空格 换行\n代码 row1 \u0026lt;!--Here are two spacebar--\u0026gt; row2 效果 row1\nrow2\n分段: 换行 换行用来表示\n代码 paragraph1 paragraph2 效果 paragraph1\nparagraph2\n设置字体属性 (Character Attribute) ~~包住表示删除线\n1~3个*包住分别表示斜体、粗体、粗斜体\n代码 ~~strikeout~~ ~~删除线~~ *italic* *斜体* **bold** **粗体** ***italic \u0026amp; bold*** ***粗斜体*** 效果 strikeout 删除线\nitalic 斜体\nbold 粗体\nitalic \u0026amp; bold 粗斜体\n列表与序号 (List and Order) 无序列表: -空格或 +空格或*空格, 后面可接[空格]空格或者[x]空格来表示复选框\n为了兼容性, 不建议混合使用, 尽管下例如此, 但只是为了演示\n代码 - list 1 + list 2 * list 3 - [ ] 这个列项没有选中 - [x] 这个列项被选中了 效果 list 1 list 2 list 3 这个列项没有选中 这个列项被选中了 有序列表: N.空格, 其中N表示起始序号\n后续数字大小无效,列表将从N开始递增, 详见下方例子\n代码 2. order 2 1. order 3 5. order 4 效果 order 2 order 3 order 4 子列表: 空格 空格 空格 空格 或 TAB\n代码 - list - list - child list - child list - child list - c c list - c c list 1. order 1. child order 2. child order 1. c c order 2. c c order 效果 list list child list child list child list c c list c c list order child order child order c c order c c order 代码与代码块 (Code and Block) 突出强调(代码): 首尾用`包住\n代码 This is the `keyword`. 效果 This is the keyword.\n代码中包含`时, 用``与空格包住, 如是: ``空格代码空格``\n代码 `` Press the `keyword`. `` 效果 Press the `keyword`.\n同理若代码中含有n个`,则需要在代码首尾用n+个反引号与1个空格包住即可\n如下方举例, 代码原文中有两个反引号, 则代码本身需要在首尾用三个或以上(例子中使用了5个)反引号与一个空格来包住\n代码 ````` We have two symbols: ``. ````` 效果 We have two symbols: ``.\n代码块: 首尾各用 ``` 包住\n可在首3个`后面指定代码语言 , 如是: ```language代码块```\n除了反引号也可使用波浪号: ~~~, 详见下方举例\n代码 ``` #include \u0026lt;stdio.h\u0026gt; //hh #define pi 3.1415926 ``` ```C #include \u0026lt;stdio.h\u0026gt; ``` ~~~c++ int main() { return 0; } ~~~ 效果 #include \u0026lt;stdio.h\u0026gt; //hh #define pi 3.1415926 #include \u0026lt;stdio.h\u0026gt; int main() { return 0; } 若代码原文中有3个`或~, 则可用3+个`或~来包住代码块\n代码 `````C char* str=\u0026#34; ``` \u0026#34;; printf(\u0026#34;%s\u0026#34;,str); ````` 效果 char* str=\u0026#34; ``` \u0026#34;; printf(\u0026#34;%s\u0026#34;,str); 除使用反引号与波浪号外, 还可以让整个代码块缩进4个或以上空格\n代码 int a=0, b=0; int c=a+b; printf(\u0026#34;c: %d\u0026#34;, c); 效果 int a=0, b=0; int c=a+b; printf(\u0026quot;c: %d\u0026quot;, c); 引用 (Quotes) 每行行首添加 \u0026gt;空格, 多层引用则增加\u0026gt;数, 见下例\n为了兼容性, 建议在引用前后各增加一行空白行\n代码 content... \u0026gt; quote 1 \u0026gt; quote 2 \u0026gt; \u0026gt; another quote 1 \u0026gt; another quote 2 \u0026gt;\u0026gt; child quote 1 \u0026gt;\u0026gt;\u0026gt; c c quote 1 content... 效果 (请忽略第一个引用, 此为本文引用) content\u0026hellip;\nquote 1 quote 2\nanother quote 1 another quote 2\nchild quote 1\nc c quote 1\ncontent\u0026hellip;\n分割线 (Segmentation Line) --- 或 ___ 或 ***, 三个或以上\n为了兼容性, 建议在前后添加空白行\n代码 content1... --- content2... 效果 content1\u0026hellip;\ncontent2\u0026hellip;\n超链接 (Links) 标准显示方式: []包住链接文本, 其后()包住链接地址, 地址后方添加空格然后用\u0026quot;\u0026quot;包住可选提示\n如是: [显示文本](链接地址 \u0026quot;可选提示\u0026quot;)\n代码 [我是一个链接](www.xxxxxx.com) [谷歌](www.google.com \u0026#34;当你鼠标指向这个链接时, 我会显示这条提示\u0026#34;) [AKIBA BLOG](syakiba.github.io \u0026#34;前往AKIBA的个人博客\u0026#34;) 效果 我是一个链接\n谷歌\nAKIBA BLOG\n直接显示链接地址时,可以使用\u0026lt;\u0026gt;包住\n代码 \u0026lt;www.google.com\u0026gt; *注意此方式需要http前缀,请见下方效果* \u0026lt;https://www.google.com\u0026gt; \u0026lt;xxxxx@gmail.com\u0026gt; 效果 \u0026lt;www.google.com\u0026gt; 注意此方式需要http前缀,请见下方效果\nhttps://www.google.com\nxxxxx@gmail.com\n引用链接分两个部分, 引用标识和引用内容\n引用标识: [显示文本] 空格 [引用标识]\n引用内容: [引用标识]:空格 链接地址 空格\u0026quot;可选提示\u0026quot; (可选提示可以用单引号、双引号、括号包住; 链接地址可以用尖括号包住也可以直接写)\n不建议使用, 作者编写本文时, 此方式一直失败\n代码 [谷歌搜索] [0] [AKIBA BLOG] [a] (other content) [0]: \u0026lt;https://www.google.com\u0026gt; [a]: syakiba.github.io \u0026#34;前往AKIBA的个人博客\u0026#34; 效果 [谷歌搜索] [0]\n[AKIBA BLOG] [a]\n(other content\u0026hellip;)\n[0]: https://www.google.com\n[a]: syakiba.github.io \u0026ldquo;前往AKIBA的个人博客\u0026rdquo;\n图片 (Pictures) 形式几乎与上述标准链接方式一样,在其前方加一个!即可\n如是: ![替换文本](图片地址 \u0026quot;可选提示\u0026quot;)\n代码 ![图片未显示时你会看到我](xxx/xxx/xxx \u0026#34;这是一个失败的图片\u0026#34;) ![谷歌LOGO](https://t12.baidu.com/it/u=4082721491,3981845853\u0026amp;fm=58 \u0026#34;看到我时,你的鼠标正在这个图片上\u0026#34;) ![百度搜索](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png) 效果 表格 须要两行来标识表格: 一行表头,一行分隔符\n|用来表示表格列数, 第二行须要3个或以上-来标识表格且列数要与表头一样\n-的左右可以加上:用来表示左右对齐(或居中), 如是: :- :-: -:\n代码 |地址|数据|类型| |-|-|-| |0x0001|FFFF|STR| |0x0001|FFFF|STR| |0x0001|FFFF|STR| |姓名|性别|性取向| |:-|:-----------------------:|--:| |张三|男|男| |李四|中|中| |桃五六七|女|外星生物| 效果 地址 数据 类型 0x0001 FFFF STR 0x0001 FFFF STR 0x0001 FFFF STR 姓名 性别 性取向 张三 男 男 李四 变性者 双性恋 桃五六七 女 外星生物 脚注 两个部分组成, 脚注标识与脚注内容, 脚注内容为当前脚注标识与下一个脚注标识之前的文本\n脚注标识: [^标识]\n脚注内容: [^标识]: 空格 脚注内容\n不建议使用, 为了兼容性建议脚注内容后面分段\n代码 脚注标识[^1]可以是字母或数字, 使用脚注[^2]功能前需确认当前处理器是否支持, 因为不是所有的markdown处理器[^3]都支持此功能. other content... [^1]: 用来标识当前位置有一条注解, 点击可以跳转的注解. other content... over. [^2]: 脚注功能不是所有处理器都支持, 语法规定脚注内容可以放在除list、quote、block外的任意地方 脚注内容遇到分段会终止(就如前方[^1]那样), 此外脚注内容遇到下一个脚注内容时也会终止正如此条脚注内容所示 [^3]: 我用来终止[^2]的内容, 因此我就不解释什么是markdown处理器了, 因为这是我乱说的词汇. 效果 脚注标识1可以是字母或数字, 使用脚注2功能前需确认当前处理器是否支持, 因为不是所有的markdown处理器3都支持此功能.\nother content\u0026hellip;\nother content\u0026hellip;\nover.\n表情的使用 (Emoji) 一是直接粘贴, 多数处理器会自动将其以markdown文本显示 (表情复制)\n二是使用简码, 如是:name:, 部分处理器支持使用表情简码 (简码查询)\n代码 😄 😆 💤 效果 😄 😆 💤\n文献: https://www.markdownguide.org/basic-syntax/\n2023年1月15日 22点03分 JP\n用来标识当前位置有一条注解, 点击可以跳转到注解.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n脚注功能不是所有处理器都支持, 语法规定脚注内容可以放在除list、quote、block外的任意地方\n脚注内容遇到分段会终止(就如前方[^1]所示那样), 此外脚注内容遇到下一个脚注内容时也会终止正如此条脚注内容所示\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n我用来终止[^2]的内容, 因此我就不解释什么是markdown处理器了, 因为这是我随便说的词汇.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://syakiba.github.io/posts/0.markdown_grammar/","summary":"markdown语法之介绍、演示、使用方式、参考","title":"MARKDOWN入门到精通"}]